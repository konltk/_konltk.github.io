[
{
	"uri": "https://kontlk.github.io/contents/",
	"title": "contents",
	"tags": [],
	"description": "",
	"content": "  Installing konltk Installing konltk\n konltk main KoNLTK Main\n "
},
{
	"uri": "https://kontlk.github.io/documents/",
	"title": "documents",
	"tags": [],
	"description": "",
	"content": "  C언어를 파이썬 모듈화 할 때 파이썬 2, 3버전 호환 가능한 매크로 \n Python extending with C \n Python extending with C class wrapping \n python 2버전 배포시 서브 모듈 설정하기 \n 오픈소스에 contribution 하기 \n 파이썬 배포 할 때 파일을 포함하는 방법 \n "
},
{
	"uri": "https://kontlk.github.io/index/",
	"title": "index",
	"tags": [],
	"description": "",
	"content": "  "
},
{
	"uri": "https://kontlk.github.io/modules/",
	"title": "modules",
	"tags": [],
	"description": "",
	"content": "  konltk modules \n "
},
{
	"uri": "https://kontlk.github.io/search/",
	"title": "About the Search Engine",
	"tags": [],
	"description": "",
	"content": " Docdock theme uses the last improvement available in hugo version 20+ to generate a json index file ready to be consumed by lunr.js javascript search engine.\nhugo generate lunrjs index.json at the root of public folder if the site only has one language or within each language subfolder. When you build the site with hugo server, hugo generates it internally and of course it don\u0026rsquo;t show up in the filesystem "
},
{
	"uri": "https://kontlk.github.io/document/",
	"title": "Konlp Document",
	"tags": [],
	"description": "",
	"content": " konlp Document konlp.detector package Module contents 이 모듈에는 파일 혹은 문자열의 문자 인코딩을 확인을 할 수 있는 class가 포함되어 있습니다.\nSubmodules konlp.detector.detector module class konlp.detector.detector.Detect  detect(text, max) Parameters: - text(string): 문자 인코딩을 확일한 텍스트 혹은 파일의 path - max(int): 문자열 혹은 파일에서 앞에서 max만큼의 문자를 확인을 합니다. max의 수가 커질수록 정확도는 향상이 되지만 속도는 더 오래 걸릴 수 있습니다. Return: \u0026ldquo;NONE\u0026rdquo;, \u0026ldquo;EUCKR\u0026rdquo;, \u0026ldquo;UTF8\u0026rdquo;, \u0026ldquo;UTF16BE\u0026rdquo;, \u0026ldquo;UTF16LE\u0026rdquo; 이 중 하나를 얻습니다. Return Type: string \nkonlp.ngram package Module contents 문자열 혹은 리스트 배열을 n-gram\u0026hellip;..\nSubModules konlp.ngram.ngram module \u0026gt;\u0026gt;\u0026gt; from konlp.ngram import ngram \u0026gt;\u0026gt;\u0026gt; n = ngram.Ngram() \u0026gt;\u0026gt;\u0026gt; n.ngram(\u0026quot;abcd\u0026quot;, 2) {('a', 'b'): 1, ('b', 'c'): 1, ('c', 'd'): 1}  class konlp.ngram.ngram.Ngram  ngram(text, n) Parameters: - text(string or list array): n-gram 할 문자열 혹은 list array - n(int): n-gram의 n Return: n-gram된 dictionary Return Type: dictionary\n\u0026lt;b\u0026gt;word_len()\u0026lt;/b\u0026gt; \u0026lt;b\u0026gt;Return:\u0026lt;/b\u0026gt; 나뉘어진 단어의 수 \u0026lt;b\u0026gt;Return Type:\u0026lt;/b\u0026gt; int \u0026lt;b\u0026gt;total_len()\u0026lt;/b\u0026gt; \u0026lt;b\u0026gt;Return:\u0026lt;/b\u0026gt; 모든 단어의 수 \u0026lt;b\u0026gt;Return Type:\u0026lt;/b\u0026gt; int \u0026lt;b\u0026gt;probabillity\u0026lt;/b\u0026gt; \u0026lt;b\u0026gt;Return:\u0026lt;/b\u0026gt; 각 단어의 빈도 확률 \u0026lt;b\u0026gt;Return Type:\u0026lt;/b\u0026gt; dictionary  \nkonlp.wordcount package Module contents \u0026hellip;.\nSubModules konlp.wordcount.ngram module \u0026gt;\u0026gt;\u0026gt; from konlp.wordcount import wordcount \u0026gt;\u0026gt;\u0026gt; wc = wordcount.WordCount() \u0026gt;\u0026gt;\u0026gt; wc.wordcount(\u0026quot;a b c d ef\u0026quot;) [('a', 1), ('b', 1), ('c', 1), ('d', 1), ('ef', 1)]  class konlp.wordcount.wordcount.WordCount  wordcount(text) Parameters: - text(string or list array): whitespace 기준으로 나뉘는 단어들의 수 Return: 단어와 수가 튜플로 이루어진 list Return Type: list \nkonlp.pos package Module contents \u0026hellip;.\nSubModules konlp.pos.index module ....  class konlp.pos.index.Index  주어진 텍스트에서 명사만 추출하는 명사 추출기입니다. dic_init(path) 사전을 설정하는 함수입니다. Parameters: - path(string): 설정할 사전의 위치 Return: 잘 설정이 되었으면 0, 아니면 1이 리턴이 됩니다. Return Type: int index(data) 이 함수를 사용하기전에 dic_init 함수를 사용하여서 사전을 설정을 해야합니다. Parameters: - data(string): 명사를 추출하고 싶은 문자열이나 혹은 파일의 path Return: (원본, 명사 리스트) 튜플로 이루어진 리스트 Return Type: list \nkonlp.pos.ham module ....  class konlp.pos.ham.Ham  형태소 분석기 dic_init(path) 사전을 설정하는 함수입니다. Parameters: - path(string): 설정할 사전의 위치 Return: 잘 설정이 되었으면 0, 아니면 1이 리턴이 됩니다. Return Type: int morpha(data) 이 함수를 사용하기전에 dic_init 함수를 사용하여서 사전을 설정을 해야합니다. Parameters: - data(string): 형태소 분석을 할 문자열 Return: 튜플들로 이루어진 리스트 Return Type: list \n"
},
{
	"uri": "https://kontlk.github.io/modules/modules/",
	"title": "konltk modules",
	"tags": [],
	"description": "",
	"content": " konltk moduels\nkonltk.detector package Module contents 이 모듈에는 파일 혹은 문자열의 문자 인코딩을 확인을 할 수 있는 class가 포함되어 있습니다.\nSubmodules konltk.detector.detector module class konltk.detector.detector.Detect detect(text, max) Parameters: - text(string): 문자 인코딩을 확일한 텍스트 혹은 파일의 path - max(int): 문자열 혹은 파일에서 앞에서 max만큼의 문자를 확인을 합니다. max의 수가 커질수록 정확도는 향상이 되지만 속도는 더 오래 걸릴 수 있습니다. Return: \u0026ldquo;NONE\u0026rdquo;, \u0026ldquo;EUCKR\u0026rdquo;, \u0026ldquo;UTF8\u0026rdquo;, \u0026ldquo;UTF16BE\u0026rdquo;, \u0026ldquo;UTF16LE\u0026rdquo; 이 중 하나를 얻습니다. Return Type: string\nkonltk.ngram package Module contents 문자열 혹은 리스트 배열을 n-gram\u0026hellip;..\nSubModules konltk.ngram.ngram module \u0026gt;\u0026gt;\u0026gt; from konltk.ngram import ngram \u0026gt;\u0026gt;\u0026gt; n = ngram.Ngram() \u0026gt;\u0026gt;\u0026gt; n.ngram(\u0026quot;abcd\u0026quot;, 2) {('a', 'b'): 1, ('b', 'c'): 1, ('c', 'd'): 1}  class konltk.ngram.ngram.Ngram ngram(text, n) Parameters: - text(string or list array): n-gram 할 문자열 혹은 list array - n(int): n-gram의 n Return: n-gram된 dictionary Return Type: dictionary\nword_len() Return: 나뉘어진 단어의 수 Return Type: int\ntotal_len() Return: 모든 단어의 수 Return Type: int\nprobabillity Return: 각 단어의 빈도 확률 Return Type: dictionary\nkonltk.wordcount package Module contents \u0026hellip;.\nSubModules konltk.wordcount.ngram module \u0026gt;\u0026gt;\u0026gt; from konltk.wordcount import wordcount \u0026gt;\u0026gt;\u0026gt; wc = wordcount.WordCount() \u0026gt;\u0026gt;\u0026gt; wc.wordcount(\u0026quot;a b c d ef\u0026quot;) [('a', 1), ('b', 1), ('c', 1), ('d', 1), ('ef', 1)]  class konltk.wordcount.wordcount.WordCount wordcount(text) Parameters: - text(string or list array): whitespace 기준으로 나뉘는 단어들의 수 Return: 단어와 수가 튜플로 이루어진 list Return Type: list\nkonltk.pos package Module contents \u0026hellip;.\nSubModules konltk.pos.index module ....  class konltk.pos.index.Index 주어진 텍스트에서 명사만 추출하는 명사 추출기입니다. dic_init(path) 사전을 설정하는 함수입니다. Parameters: - path(string): 설정할 사전의 위치 Return: 잘 설정이 되었으면 0, 아니면 1이 리턴이 됩니다. Return Type: int index(data) 이 함수를 사용하기전에 dic_init 함수를 사용하여서 사전을 설정을 해야합니다. Parameters: - data(string): 명사를 추출하고 싶은 문자열이나 혹은 파일의 path Return: (원본, 명사 리스트) 튜플로 이루어진 리스트 Return Type: list\nkonltk.pos.ham module ....  class konltk.pos.ham.Ham 형태소 분석기 dic_init(path) 사전을 설정하는 함수입니다. *Parameters: - path(string): 설정할 사전의 위치 Return: 잘 설정이 되었으면 0, 아니면 1이 리턴이 됩니다. Return Type: int morpha(data) 이 함수를 사용하기전에 dic_init 함수를 사용하여서 사전을 설정을 해야합니다. *Parameters: - data(string): 형태소 분석을 할 문자열 Return: 튜플들로 이루어진 리스트 Return Type: list\n"
},
{
	"uri": "https://kontlk.github.io/",
	"title": "Korean Natural Language Toolkit",
	"tags": [],
	"description": "",
	"content": " Korean Natural Language Toolkit 한국어 자연어 처리 tool kit.\nLinux에서 사용이 가능합니다.\nMain features  형태소 분석 명사 추출 n gram  Some Sample import konlp.  "
},
{
	"uri": "https://kontlk.github.io/_footer/",
	"title": "footer",
	"tags": [],
	"description": "",
	"content": "Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n"
},
{
	"uri": "https://kontlk.github.io/_header/",
	"title": "header",
	"tags": [],
	"description": "",
	"content": "Test Site for KoNLP and KoNLTK\n"
},
{
	"uri": "https://kontlk.github.io/tags/c/",
	"title": "C",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://kontlk.github.io/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://kontlk.github.io/tags/controbution/",
	"title": "Controbution",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://kontlk.github.io/credits/",
	"title": "Credits",
	"tags": [],
	"description": "contributors and packages used by hugo-theme-docdock",
	"content": " github contributors .ghContributors{ display:flex; flex-flow: wrap; align-content: flex-start } .ghContributors  div{ width: 50% ; display: inline-flex; margin-bottom: 5px; } .ghContributors  div label{ padding-left: 4px ; } .ghContributors  div span{ font-size: x-small; padding-left: 4px ; }   @hyunyoung2 2 commits   @YoungHunCho 1 commits   Other contributors  @hyunyoung2 supports and advices   Packages and libraries  Bootstrap - front-end framework mermaid - generation of diagram and flowchart from text in a similar manner as markdown font awesome - the iconic font and CSS framework jQuery - The Write Less, Do More, JavaScript Library lunr - Lunr enables you to provide a great search experience without the need for external, server-side, search services\u0026hellip; JavaScript-autoComplete - An extremely lightweight and powerful vanilla JavaScript completion suggester. clipboard.js - copy text to clipboard highlight.js - Javascript syntax highlighter modernizr - A JavaScript toolkit that allows web developers to use new CSS3 and HTML5 features while maintaining a fine level of control over browsers that don\u0026rsquo;t support reveal-js - The HTML Presentation Framework  Tooling  Netlify - Continuous deployement and hosting of this documentation Hugo    "
},
{
	"uri": "https://kontlk.github.io/documents/extending-python3-c/",
	"title": "C언어를 파이썬 모듈화 할 때 파이썬 2, 3버전 호환 가능한 매크로",
	"tags": ["python", "c"],
	"description": "",
	"content": " 모듈 초기화 파이썬 2버전을 확장할때에는 init+모듈이름 함수 이내에 \u0026lsquo;Py_InitModule\u0026rsquo; 과 같은 함수를 사용하여서 모듈을 초기화 했다.\n파이썬 3버전에서는 \u0026lsquo;PyModule_Create\u0026rsquo; 함수를 사용해서 모듈을 초기화 한다. PyModule_Create 함수를 호출할 때에는 PyModuleDef 구조체를 인자로 넘거야 한다.\nstatic struct PyModuleDef moduledef = { PyModuleDef_HEAD_INIT, \u0026quot;lib\u0026quot;, /* name of module */ NULL, /* module documentation, may be NULL */ -1, /* size of per-interpreter state of the module, or -1 if the module keeps state in global variables. */ methods\t/* method_list */ }; //main PyMODINIT_FUNC PyInit_lib(void){ return PyModule_Create(\u0026amp;moduledef); }  파이썬 2버전과 3버전을 같이 사용하고 싶으면 #if 를 사용한다.\n#if PY_MAYJOR_VERSION \u0026gt;= 3 static struct PyModuleDef moduledef = { PyModuleDef_HEAD_INIT, \u0026quot;lib\u0026quot;, /* name of module */ NULL, /* module documentation, may be NULL */ -1, /* size of per-interpreter state of the module, or -1 if the module keeps state in global variables. */ methods\t/* method_list */ }; #endif //main PyMODINIT_FUNC PyInit_lib(void){ { #if PY_MAJOR_VERSION \u0026gt;= 3 m = PyModule_Create(\u0026amp;moduledef); #else m = Py_InitModule3(\u0026quot;lib\u0026quot;, methods, \u0026quot;모듈 설명\u0026quot;); #endif return m; }  메인 파이썬 2버전에서는 아래와 같은 형식으로 메인 함수를 만들었다. \u0026gt; void init\u0026lt;모듈이름\u0026gt;\n하지만 파이썬 3버전에서는 아래와 같이 한다. \u0026gt; PyMODINITFUNC PyInit\u0026lt;모듈이름\u0026gt;\n파이썬 2버전과 3버전을 한꺼번에 되는 코드는 아래와 같이 할 수 있다.\nPyMODINIT_FUNC #if PY_MAJOR_VERSION \u0026gt;= 3 PyInit_\u0026lt;모듈이름\u0026gt;() #else init\u0026lt;모듈이름\u0026gt;() #endif { ... }  이것을 더 편히 간단히 한다면\n#if PY_MAJOR_VERSION \u0026gt;= 3 #define MOD_INIT(name) PyMODINIT_FUNC PyInit_##name() #else #define MOD_INIT(name) PyMODINIT_FUNC init##name() MODINIT(모듈 이름){ ... }  위의 각각 정의한것을 합치게 되면\n#if PY_MAJOR_VERSION \u0026gt;= 3 static struct PyModuleDef moduledef = { PyModuleDef_HEAD_INIT, \u0026quot;lib\u0026quot;, /* name of module */ NULL, /* module documentation, may be NULL */ -1, /* size of per-interpreter state of the module, or -1 if the module keeps state in global variables. */ methods } #endif static PyObject* moduleinit(){ PyObject* m; #if PY_MAJOR_VERSION \u0026gt;= 3 m = PyModule_Create(\u0026amp;moduledef); #else m = Py_InitModule(\u0026quot;lib\u0026quot;, methods); #endif ... return m; } #if PY_MAJOR_VERSION \u0026gt;= 3 PyMODINIT_FUNC initlib(){ moduleinit(); } #else PyMODINIT_FUNC PyInit_lib(){ return moduleinit(); } #endif  좀 더 깔끔하게 한다면\n#if PY_MAJOR_VERSION \u0026gt;= 3 #define MOD_INIT(name) PyMODINIT_FUNC PyInt_##name() #define MOD_DEF(ob, name, doc, methids) \\ static PyModuleDef moduledef = { \\ PyModuleDef_HEAD_INIT, name, doc, -1, methids};\\ ob = PyModule_Create(\u0026amp;moduledef); #else #define MOD_INIT(name) void init##name() #define MOD_DEF(ob, name, doc, methids) \\ ob = Py_InitModule3(name, methods, doc); #endif MOD_INIT(lib){ PyObject* m; MOD_DEF(m, \u0026quot;lib\u0026quot;, module__doc__, methids) ... return m; }  참조 http://python3porting.com/cextensions.html\n"
},
{
	"uri": "https://kontlk.github.io/showcase/",
	"title": "Docdock-built Sites",
	"tags": [],
	"description": "Hugo-built Sites with docdock theme",
	"content": " https://invincible.site/ by @shazic https://bitfan.io/ by @vjeantet "
},
{
	"uri": "https://kontlk.github.io/categories/extend-python/",
	"title": "Extend Python",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://kontlk.github.io/tags/github/",
	"title": "Github",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://kontlk.github.io/contents/installing-konltk/",
	"title": "Installing konltk",
	"tags": [],
	"description": "Installing konltk",
	"content": " Installing konltk konltk는 맥을 제외한 리눅스 계열에서 사용이 가능합니다.\n코드 다운받기 명령어로 코드를 다운받는 방법 git clone https://github.com/konltk/konltk  Github페이지로 들어가서 코드를 다운받는 방법 konltk github 주소에 접속하여 코드를 다운 받습니다. 설치하기 설치는 터미널의 명령어로 진행을 합니다. 설치전 python-dev(파이썬 3.xx 버전을 사용시 python3-dev)이 설치가 되어 있어야 합니다.\n코드를 다운 받은 후(Github 페이지에서 다운을 받았으면 unzip도 해야합니다) 가장 최상위 폴더로 이동을 합니다. 이동 후 sudo python setup.py install(파이썬 3.xx 버전을 사용시 sudo python3 setup.py install) 명령어를 통해서 설치를 진행합니다.\n$ cd konltk konltk$ sudo python setup.py install  사용하기전 설치하고 나서 바로 사용하실경우 source /etc/profile.d 명령어를 터미널에서 실행을 한 후 사용하시면 문제없이 사용이 가능합니다. 이 명령어는 피씨를 재부팅을 하면 다시 하실 필요 없습니다. 다만 재부팅을 하지 않을 경우는 사용할 터미널에서 위의 명령어를 실행 후 사용해야합니다.\n"
},
{
	"uri": "https://kontlk.github.io/categories/open-source/",
	"title": "Open Source",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://kontlk.github.io/tags/open-source/",
	"title": "Open Source",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://kontlk.github.io/tags/python/",
	"title": "Python",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://kontlk.github.io/documents/python-extending-with-c/",
	"title": "Python extending with C",
	"tags": ["python", "c"],
	"description": "",
	"content": " This document is based on the Python 2.x version.\nAs a python extending language c Python work when load module 파이썬에서 모듈을 로드를 할 때에 아래와 같은 순서로 모듈을 찾게 된다. \u0026gt; * 기본 모듈(soket, time 등) \u0026gt; * c로 만들어진 dll 파일 \u0026gt; * 자체 제작한 파이썬 모듈\n예시로 만약 파이썬에서 import mylib을 수행한다면, 파이썬에서는 sys.module과 sys.path의 디렉토리를 검색하여 mylib이라는 모듈을 찾는다.\nCreate module using language c c언어로 된 코드를 파이썬에서 로드하기 위해서는 c code에 대한 라이브러리 파일이 필요하다. Python extendion에서는 .so(리눅스)라이브러리 파일과 .pyd(윈도우) 라이브러리 파일이 필요하게 된다. .so 파일이나 .pyd파일을 파이썬이 설치된 디렉토리의 \u0026lsquo;Lib/site-package\u0026rsquo; 폴더에 복사를 하면 된다. 간단히 정리를 하면 \u0026gt; 1. c code를 컴파일하여 .so or .pyd 라이브러리 파일로 빌드를 한다 \u0026gt; 2. 빌드하여 나온 라이브러리 파일을 파이썬이 설치된 폴더의 Lib/site-package 폴더에 복사를 한다.\n위의 두 과정으로 진행된다.\nSample code //mylib.c #include \u0026quot;Python.h\u0026quot; #include \u0026lt;stdio.h\u0026gt; static PyObject* ErrorObject; // 실제 동작하는 함수 static PyObject* write_log(PyObject *self, PyObject *args) // 인자는 이와같이 고정된다. { char* msg; if(!PyArg_ParseTuple(args, \u0026quot;s\u0026quot;, \u0026amp;msg)) return NULL; printf(“c import test\\n”); return Py_BuildValue(\u0026quot;i\u0026quot;, 0); } /* methods 구조체 배열에 지정되는 정보는 {\u0026quot;실제사용할 메쏘드명\u0026quot;, 메쏘드명에 대응하는 실제 동작하는 함수명, 인자 종류} */ static struct PyMethodDef methods[] = { {\u0026quot;wlog\u0026quot;, write_log, METH_VARARGS}, {NULL, NULL} }; void initmylib() { PyObject* m; // Py_InitModule(\u0026quot;모듈명\u0026quot;, 이모듈에 적용된 메쏘드들을 담을 구조체배열 포인터) m = Py_InitModule(\u0026quot;mylib\u0026quot;, methods); ErrorObject = Py_BuildValue(\u0026quot;s\u0026quot;, \u0026quot;error\u0026quot;); }  파이썬이 c 모듈을 import 하게되면 초기화를 위해 \u0026lsquo;init+모듈이름\u0026rsquo;으로 된 함수를 호출한다. 모듈이름이 mylib이면 initmylib()을 호출한다.\n즉, c의 main함수의 역할이 \u0026lsquo;init_모듈이름\u0026rsquo;으로 된 함수이다.\n이 c파일을 컴파일하기 위해서 파이썬 파일이 필요하다.\n# setup.py from distutils.core import setup, Extension setup(name = \u0026quot;mylib\u0026quot;, version = \u0026quot;1.0\u0026quot;, description = \u0026quot;print log\u0026quot;, author = \u0026quot;sample\u0026quot;, author_email = \u0026quot;sample@sample.com\u0026quot;, url = \u0026quot;google.com\u0026quot;, ext_modules = [Extension(\u0026quot;mylib\u0026quot;, [\u0026quot;mylib.c\u0026quot;])] )  Compile 위에서 만든 c파일과 python파일을 같은 디렉토리에 넣러두고 아래의 명령어를 통하여서 컴파일을 하게된다. \u0026gt; python setup.py install\n위의 명령어를 입력하면 자동적으로 컴파일 후 .so파일이나 .pyd파일을 \u0026lsquo;Lib/site-package\u0026rsquo; 폴더에 복사가 된다. 컴파일을 할때는 리눅스에서는 gcc를 호출하고 윈도우에서는 visual c컴파일러를 호출한다.\ncompile on window 파이썬에서는 c를 컴파일할 때 vc++를 호출하기 때문에 컴퓨터에 비주얼 스튜디오가 설치되어 있어야하며, 설치된 비주얼스튜디로의 버전을 맞춰야한다. \u0026gt; python\\Lib\\distutils\\msvs9compiler.py\n위의 path는 파이썬이 설치된 디렉토리이며 파이썬 파일은 파이썬 버전별로 달리질 수 있다.\n파이썬 파일을 연 후 get_build_version 함수의 리턴값을 현재의 vc 버전에 맞춰서 적는다. vc 버전 정보\n visual C++ 2015 (14.0) visual C++ 2013 (12.0) visual C++ 2012 (11.0) visual C++ 2010 (10.0)\n compule option Setup.py를 install할때 파일안에서 정의한 c파일을 컴파일을 하는데 컴파일 옵션을 사용 할 수 있다. 평소 gcc를 사용할 때 쓰는 “-w –o –Wall” 등 여러 컴파일 옵션을 사용하는데 이 옵션들을 python extending에서도 사용할 수 있다.\nimport os import sys from distutils.core import setup, Extension # from setuptools import setup, Extension setup(name = \u0026quot;konlp\u0026quot;, version = \u0026quot;1.0\u0026quot;, py_modules=[\u0026quot;konlp.detector.detector\u0026quot;, \u0026quot;konlp.ngram.ngram\u0026quot;, \u0026quot;konlp.pos.index\u0026quot;, \u0026quot;konlp.wordcount.wordcount\u0026quot;], ext_modules = [Extension(\u0026quot;konlp.c.codescan\u0026quot;, extra_compile_args=[\u0026quot;-w\u0026quot;], sources=[\u0026quot;konlp/detector/pydetector.c\u0026quot;]), Extension(\u0026quot;konlp.c.wordcount\u0026quot;, extra_compile_args=[\u0026quot;-w\u0026quot;], sources=[\u0026quot;konlp/wordcount/pywordcount.c\u0026quot;, \u0026quot;konlp/wordcount/wordcount.c\u0026quot;, \u0026quot;konlp/wordcount/wordcount-main.c\u0026quot;, \u0026quot;konlp/wordcount/wordcount-sort.c\u0026quot;]), Extension(\u0026quot;konlp.c.index\u0026quot;, extra_compile_args=[\u0026quot;-Wall\u0026quot;], extra_link_args=[\u0026quot;-L.\u0026quot;, \u0026quot;-lindex\u0026quot;], sources=[\u0026quot;konlp/pos/pyindex.c\u0026quot;])] )  위는 setup.py 예제 소스이다. 중간에 보면 extra_compile_args가 있는데 이 부분을 통하여서 각각의 컴파일 옵션을 줄 수 있다.\ncompile link 위 1.5.1 의 내용처럼 각각의 c파일에 대하여서 컴파일 링크를 할 수 있다.\nimport os import sys from distutils.core import setup, Extension # from setuptools import setup, Extension setup(name = \u0026quot;konlp\u0026quot;, version = \u0026quot;1.0\u0026quot;, py_modules=[\u0026quot;konlp.detector.detector\u0026quot;, \u0026quot;konlp.ngram.ngram\u0026quot;, \u0026quot;konlp.pos.index\u0026quot;, \u0026quot;konlp.wordcount.wordcount\u0026quot;], ext_modules = [Extension(\u0026quot;konlp.c.codescan\u0026quot;, extra_compile_args=[\u0026quot;-w\u0026quot;], sources=[\u0026quot;konlp/detector/pydetector.c\u0026quot;]), Extension(\u0026quot;konlp.c.wordcount\u0026quot;, extra_compile_args=[\u0026quot;-w\u0026quot;], sources=[\u0026quot;konlp/wordcount/pywordcount.c\u0026quot;, \u0026quot;konlp/wordcount/wordcount.c\u0026quot;, \u0026quot;konlp/wordcount/wordcount-main.c\u0026quot;, \u0026quot;konlp/wordcount/wordcount-sort.c\u0026quot;]), Extension(\u0026quot;konlp.c.index\u0026quot;, extra_compile_args=[\u0026quot;-Wall\u0026quot;], extra_link_args=[\u0026quot;-L.\u0026quot;, \u0026quot;-lindex\u0026quot;], sources=[\u0026quot;konlp/pos/pyindex.c\u0026quot;])] )  위와 동일한 setup.py 예제이다. 중간에 보면 extra_link_args가 있는데 이 부분을 통하여서 각각의 컴파일 링크를 할 수 있다.\nExample c 파일과 파이썬 파일을 한 디렉토리에 위치한다. python setup.py install 위의 명령어를 실행한다.\n그 후, 파이썬을 실행하여 확인한다.\n\u0026gt;\u0026gt; import mylib \u0026gt;\u0026gt; mylib.wlog(\u0026quot;\u0026quot;) c import test  sub module or sub package 파이썬에서는 폴더를 기준으로 sub module 혹은 sub package 가 정해진다.\ndir | +-- test.py | +-- package | +-- __init__.py | +-- subpackage | +-- __init__.py | +-- module.py  파이썬에서 위와 같은 디렉토리 구조를 가지고 있다면 test.py에서 package/subpackage/module를 import하고 싶다면 import package.subpackage.module 위처럼 . 으로서 디렉토리를 하위 모듈 혹은 패키지를 접근이 가능하다.\n하지만 c extending을 사용을 한다면 디렉토리 구조로서 하위 모듈 혹은 패키지를 사용을 못한다. 그러므로 c code 중 Py_InitModule 을 할때 자기가 사용하고 싶은 package명을 입력을 하면된다.\n... m = Py_InitModule3(\u0026quot;konlp.c.wordcount\u0026quot;, \u0026quot;wordcount c code\u0026quot;, methods); ...  위의 예제의 konlp.c.wordcount 처럼 사용하고 싶은 pacakge명을 입력을 하면 된다.\nBuilt-in method initmylib에서 Py_initMoudle 할 때 인자로 PyMethidDef 구조페 배열을 넘긴다. 이 구조체 배열을 method table로서 파이썬에서 호출될 메서드들의 목록을 나타낸다. 구조는 {\u0026ldquo;메서드\u0026rdquo;, 구현된 메서드, 호출규약, \u0026ldquo;설명\u0026rdquo;}으로 되어있다. 구조체 배열의 마지막 변수는 sentinel로서 {NULL, NULL}를 넣어준다.\n구조체 배열은 아래와 같이 작성을 하면 된다.\nstatic struct PyMethodDef methods[] ={ {\u0026quot;get\u0026quot;, get_sample_text, METH_VARARGS}, {\u0026quot;wordcountToFile\u0026quot;, wordCountToFile, METH_VARARGS}, {NULL, NULL} }  함수의 형식은\nstatic PyObject* method(PyObject *self, PyObject *args){ return Py_BuildValue(\u0026quot;\u0026quot;); }  위와 같이 되어있다.\nParameter 함수를 호출할 때 인자를 사용하는데 인자는 PyArg_ParseTuple를 이용하여 파싱한다.\n사용법 예시로는\nif(!PyArg_ParseTuple(args,\u0026quot;s|s\u0026quot;, \u0026amp;input_file, \u0026amp;output_file)) return NULL; }  위처럼 사용 할 수 있다.\nPyArg_ParseTuple를 사용할 때 두번째 인자로 전해받을 인자의 형식을 정하는데 보통 s - string, i - integer, f - float, d - double 등의 여러 형식이 있다.\nchar *options_string, *input, *output = \u0026quot;output.txt\u0026quot;; char **argument; int i = 0; int num_of_input = 0; if(!PyArg_ParseTuple(args, \u0026quot;sss\u0026quot;, \u0026amp;option_string, \u0026amp;input, \u0026amp;output)){ return NULL; }  char *input, *output = \u0026quot;output.txt\u0026quot;; char *argument_list[3] = {0}; if(!PyArg_ParseTuple(args, \u0026quot;ss\u0026quot;, \u0026amp;input, \u0026amp;output)){ return NULL; }  형식의 리스트는 c-api 여기서 볼 수 있다.\nParameter example int ok; int i, j; long k, l; const char *s; int size; ok = PyArg_ParseTuple(args, \u0026quot;\u0026quot;); /* No arguments */ /* Python call: f() */ ok = PyArg_ParseTuple(args, \u0026quot;s\u0026quot;, \u0026amp;s); /* A string */ /* Possible Python call: f('whoops!') */ ok = PyArg_ParseTuple(args, \u0026quot;lls\u0026quot;, \u0026amp;k, \u0026amp;l, \u0026amp;s); /* Two longs and a string */ /* Possible Python call: f(1, 2, 'three') */ ok = PyArg_ParseTuple(args, \u0026quot;(ii)s#\u0026quot;, \u0026amp;i, \u0026amp;j, \u0026amp;s, \u0026amp;size); /* A pair of ints and a string, whose size is also returned */ /* Possible Python call: f((1, 2), 'three') */ { const char *file; const char *mode = \u0026quot;r\u0026quot;; int bufsize = 0; ok = PyArg_ParseTuple(args, \u0026quot;s|si\u0026quot;, \u0026amp;file, \u0026amp;mode, \u0026amp;bufsize); /* A string, and optionally another string and an integer */ /* Possible Python calls: f('spam') f('spam', 'w') f('spam', 'wb', 100000) */ } { int left, top, right, bottom, h, v; ok = PyArg_ParseTuple(args, \u0026quot;((ii)(ii))(ii)\u0026quot;, \u0026amp;left, \u0026amp;top, \u0026amp;right, \u0026amp;bottom, \u0026amp;h, \u0026amp;v); /* A rectangle and a point */ /* Possible Python call: f(((0, 0), (400, 300)), (10, 10)) */ } { Py_complex c; ok = PyArg_ParseTuple(args, \u0026quot;D:myfunction\u0026quot;, \u0026amp;c); /* a complex, also providing a function name for errors */ /* Possible Python call: myfunction(1+2j) */ }  Variable int ok; int i, j; long k, l; const char *s; int size; ok = PyArg_ParseTuple(args, \u0026quot;\u0026quot;); /* No arguments */ /* Python call: f() */ ok = PyArg_ParseTuple(args, \u0026quot;s\u0026quot;, \u0026amp;s); /* A string */ /* Possible Python call: f('whoops!') */ ok = PyArg_ParseTuple(args, \u0026quot;lls\u0026quot;, \u0026amp;k, \u0026amp;l, \u0026amp;s); /* Two longs and a string */ /* Possible Python call: f(1, 2, 'three') */ ok = PyArg_ParseTuple(args, \u0026quot;(ii)s#\u0026quot;, \u0026amp;i, \u0026amp;j, \u0026amp;s, \u0026amp;size); /* A pair of ints and a string, whose size is also returned */ /* Possible Python call: f((1, 2), 'three') */ { const char *file; const char *mode = \u0026quot;r\u0026quot;; int bufsize = 0; ok = PyArg_ParseTuple(args, \u0026quot;s|si\u0026quot;, \u0026amp;file, \u0026amp;mode, \u0026amp;bufsize); /* A string, and optionally another string and an integer */ /* Possible Python calls: f('spam') f('spam', 'w') f('spam', 'wb', 100000) */ } { int left, top, right, bottom, h, v; ok = PyArg_ParseTuple(args, \u0026quot;((ii)(ii))(ii)\u0026quot;, \u0026amp;left, \u0026amp;top, \u0026amp;right, \u0026amp;bottom, \u0026amp;h, \u0026amp;v); /* A rectangle and a point */ /* Possible Python call: f(((0, 0), (400, 300)), (10, 10)) */ } { Py_complex c; ok = PyArg_ParseTuple(args, \u0026quot;D:myfunction\u0026quot;, \u0026amp;c); /* a complex, also providing a function name for errors */ /* Possible Python call: myfunction(1+2j) */ }  List PyObject 배열을 만들기 위해서는 PyList_New를 사용하여 만든다. PyObject *dlist = PyList_New(length); 리스트를 만든후 PyList_SetItem 으로 원하는 인덱스의 변수를 수정할 수 있다.\nPyList_SetItem(dlist, i, PyString_FromString(msg)); 리스트의 변수를 추가를 하고 싶다면 PyList_Append를 이용하여 item을 추가 할 수 있다. PyList_Append(dlist, PyString_FromString(msg));\nPyObjecy *dlist = PyList_New(0); int i = 0; while(1){ char msg[1000]; fscanf(sample_file, \u0026quot;%s\u0026quot;, msg); if(i++ == 1000 || feof(sample_file)) break; PyList_Append(dlist, PyString_FromString(msg)); } return dlist; PyList_Append(dlist, Py_BuildValue(\u0026quot;(is)\u0026quot;, num, msg));  이 예제처럼 하게되며, 튜플형식으로 만들어진다.\nDefining New Types Python extendion에는 C에 없는 클래스를 구현가능하게 되어있다.\nstatic PyTypeObject noddy_NoddyType = { PyVarobject_HEAD_INIT(NULL, 0), \u0026quot;noddy.Noddy\u0026quot;, sizeof(noddy_NoddyObject),\t/* tp_name */ 0,\t/* tp_basicsize */ 0, /* tp_itemsize */ 0, /* tp_dealloc */ 0, /* tp_print */ 0, /* tp_getattr */ 0, /* tp_setattr */ 0, /* tp_compare */ 0, /* tp_repr */ 0, /* tp_as_number */ 0, /* tp_as_sequence */ 0, /* tp_as_mapping */ 0, /* tp_hash */ 0,\t/* tp_call */ 0, /* tp_str */ 0, /* tp_getattro */ 0, /* tp_setattro */ 0,\t/* tp_as_buffer */ 0,\t/* tp_flags */ Py_TPFLAGS_DEFAULT,\t/* tp_flags */ \u0026quot;Noddy objects\u0026quot;,\t/* tp_doc */ };  위 사진과 같은 PyTypeObject 변수를 선언한다. 이 변수는 pymodule레 object를 추가하는데 있어서 사용된다. PyModule_AddObject(m, \u0026quot;Noddy\u0026quot;, (PyObject*) \u0026amp;noddy_NoddyType);\n위 처럼 모듈을 오브젝트를 추가하면 파이썬에서 클래스처럼 사용이 가능하다.\nimport mylib c1 = mylib.Noddy()  Member variable typedef struct{ PyObeject_HEAD PyObject* input; PyObject* output; PyObject* option; int type; }\tNoddy;  위와 같은 구조체의 건언으로 변수처럼 사용가능하다.\nimport mylib c1 = mylib.Noddy() c1.type = 1 c1.input = \u0026quot;input\u0026quot;  Member method satic PyMethodDef Noddy_methods[] = { {\u0026quot;setOption\u0026quot;, (PyCFunction)setOption, METH_VARARGS}, {\u0026quot;setFile\u0026quot;, (PyCFunction)setFile, METH_VARARGS}, {\u0026quot;setString\u0026quot;, (PyCFunction)setString, METH_VARARGS}, {NULL} }  PyMethodDef 배열을 만든 후,\nstatic PyTypeObject NoddyType = { PyVarObject_HEAD_INIT(NULL, 0) \u0026quot;noddy.Noddy\u0026quot;, /* tp_name */ sizeof(Noddy), /* tp_basicsize */ 0, /* tp_itemsize */ (destructor)Noddy_dealloc, /* tp_dealloc */ 0, /* tp_print */ 0, /* tp_getattr */ 0, /* tp_setattr */ 0, /* tp_compare */ 0, /* tp_repr */ 0, /* tp_as_number */ 0, /* tp_as_sequence */ 0, /* tp_as_mapping */ 0, /* tp_hash */ 0, /* tp_call */ 0, /* tp_str */ 0, /* tp_getattro */ 0, /* tp_setattro */ 0, /* tp_as_buffer */ Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, /* tp_flags */ \u0026quot;Noddy objects\u0026quot;, /* tp_doc */ 0, /* tp_traverse */ 0, /* tp_clear */ 0, /* tp_richcompare */ 0, /* tp_weaklistoffset */ 0, /* tp_iter */ 0, /* tp_iternext */ Noddy_methods, /* tp_methods */ Noddy_members, /* tp_members */ 0, /* tp_getset */ 0, /* tp_base */ 0, /* tp_dict */ 0, /* tp_descr_get */ 0, /* tp_descr_set */ 0, /* tp_dictoffset */ (initproc)Noddy_init, /* tp_init */ 0, /* tp_alloc */ Noddy_new, /* tp_new */ };  PyTypeObject 구조체를 선언할 때 tp_methods 부분에 구조체배열을 입력한다.\n참조 http://egloos.zum.com/batsu05/v/839472 http://qwefgh90.github.io/sphinx/python/translating_extending.html https://docs.python.org/2/extending/extending.html https://docs.python.org/2/c-api/string.html https://docs.python.org/2/extending/newtypes.html\n"
},
{
	"uri": "https://kontlk.github.io/documents/python-extending-with-c-class-wrapping/",
	"title": "Python extending with C class wrapping",
	"tags": ["python", "c"],
	"description": "",
	"content": " intro 가끔 c로 작성한 코드가 python으로 작성한 코드보다 효율이 좋을때가 있습니다. 이럴때는 파이썬에서도 c로 작성한 코드를 사용할 수 있게 확장을 할 수 있습니다. 이 문서에서는 c로 작성된 코드를 사용하여서 파이썬에서 ‘class’로 사용하기 위해서 wrapping을 하는 방법을 정리한 것입니다.\nc에서는 함수부분만 정의 나머지 작업은 python 내에서 구현 python extending with c 방식으로 c로 주요 함수만 구현 python에서 제공하는 python c extending을 이용하여서 주요 함수를 c로 구현을 한다.\nstatic PyObject* wordcount(PyObject* self, PyObject* args){ int is_add = 0, n_uniqwords, n_words; char* input, *output_file = OUTPUT; PyObject *dlist = PyDict_New(); PyObject *result_list = PyList_New(0); int i; FILE* temp_output_file; WORDCNT_STR Text={0}, *wp=\u0026amp;Text; if(!PyArg_ParseTuple(args, \u0026quot;si\u0026quot;, \u0026amp;input, \u0026amp;is_add)) return NULL; if(checkInputType(input) == TY_TEXT){ FILE *temp_intput_file = fopen(TEMP, \u0026quot;w\u0026quot;); fprintf(temp_intput_file, \u0026quot;%s\u0026quot;, input); fclose(temp_intput_file); input = TEMP; } if(is_add) delete_accumulated_data(); n_uniqwords = word_count(input, wp, 0/*word unit*/, 0/*dont show dot*/); for(i = 0; i \u0026lt; wp-\u0026gt;n_uniqwords; i++){ int temp = wp-\u0026gt;sidx[i]; PyObject *obj = PyTuple_New(2); PyTuple_SET_ITEM(obj, 0, PY_STRING(wp-\u0026gt;words[temp])); PyTuple_SET_ITEM(obj, 1, PY_INT(wp-\u0026gt;count[temp])); PyList_Append(result_list, obj); } return result_list; } //methods list static struct PyMethodDef methods[] ={ {\u0026quot;wordcount\u0026quot;, wordcount, METH_VARARGS}, {NULL, NULL} }; //main MOD_INIT(wordcount){ PyObject* m; MOD_DEF(m, \u0026quot;konlp.c.wordcount\u0026quot;, \u0026quot;wordcount c code\u0026quot;, methods); if(m == NULL) return MOD_ERROR_VAL; return MOD_SUCCESS_VAL(m); }  위의 코드와 같이 구현을 할 수 있다. 자세히 구현하는 부분에 있어서는 “다른 문서”에 기술 되어있다. 위의 코드처럼 구현을 하면 python에서는 konlp.c.wordcount 의 패키지를 import를 하고 konlp.c.wordcount.wordcount()를 호출함으로써 주요 함수를 사용 할 수 있다. 이제 주요 함수를 호출 할 수 있으니 python에서 class를 만들어서 다른 함수를 구현하면 된다.\nimport konlp.c.wordcount import os class WordCount: def __init__(self): self.result_list = [] def wordcount(self, input = \u0026quot;\u0026quot;): self.input = input self.result_list = konlp.c.wordcount.wordcount(self.input, 1) return self.result_list  위의 코드처럼 다른 작업은 python으로 구현을 하고 중간에 보면 konlp.c.wordcount.wordcount 를 호출하였는데 이것이 c에서 작업한 함수를 호출한 부분이다.\nc의 라이브러리파일을 python에서 호출 위의 ‘python extending c방식으로 c로 주요 함수만 구현’ 에서는 c의 주요 함수를 python c extending의 문법에 맞춰서 c코드를 작성한 것이다. 하지만 python c extending 문법에 맞춰 c를 구현할 필요 없이 so파일이나 dll파일을 사용하여서 함수를 호출하여서 사용이 가능하다.\n아래의 python의 사용 예제를 들어가기전에 python 사용 예제에서 쓰인 so 파일의 c code이다.\n//my_lib.c #include \u0026quot;my_lib.h\u0026quot; void foo(char * str){ printf(\u0026quot;%d %s\\n\u0026quot;, 11, str); } //my_lib.c #include \u0026quot;my_lib.h\u0026quot; void foo(char * str){ printf(\u0026quot;%d %s\\n\u0026quot;, 11, str); }  python3에서는 ctypes 모듈을 사용한다. ctypes의 CDLL 함수를 이용하여 라이브러리 파일을 load를 한다. 간단한 예제는 아래와 같다.\nimport ctypes lib = ctypes.CDLL(\u0026quot;libmy_lib.so\u0026quot;) rv = lib.foo()  foo 함수에서는 매개변수로 문자열을 받는다. 파이썬에서 c의 문자열을 사용하기 위해서는 ctypes에 있는 c data types를 사용한다.\n   ctypes type C Type python type     c_bool _Bool bool(1)   c_char char 1-character bytes object   c_wchar wchar_t 1-character string   c_byte char int   c_ubyte unsigned char int   c_short c_short int   c_ushort unsigned short int   c_int int int   c_uint unsigned int int   c_long long int   c_ulong unsigned long int   c_longlong __int64 or long long int   c_size_t size_t int   c_ssize_t ssize_t ot Py_ssize_t int   c_float float float   c_double double float   c_longdouble long double float   c_char_p char * (NUL terminated) bytes object or None   c_wchar_p wchar_t * (NUL terminated) string or None   c_void_p void * int or None    위의 표는 python에서 c 데이터 형식을 사용하기 위해서 사용하는 함수들입니다. 위의 표의 형식을 사용하여 위의 예제를 계속 진행하면,\nimport ctypes lib = ctypes.CDLL(\u0026quot;libmy_lib.so\u0026quot;) str = \u0026quot;input text\u0026quot; p = ctypes.create_string_buffer(str.encode()) rv = p.foo(p)  위와 같은 코드가 된다. 그러나 변경 가능한 메모리에 대한 포인터를 예상하는 함수에 전달하지 않도록주의해야합니다. 변경 가능한 메모리 블록이 필요하면 ctypes에는 create_string_buffer () 함수가있어 다양한 방법으로이를 생성합니다.\ncreate_string_buffer () 함수는 이전 ctypes 릴리즈의 c_string () 함수뿐만 아니라 c_buffer () 함수 (여전히 별칭으로 사용 가능)를 대체합니다. C 유형 wchar_t의 유니 코드 문자를 포함하는 변경 가능한 메모리 블록을 작성하려면 create_unicode_buffer () 함수를 사용하십시오.\n위의 대한 설명은 https://docs.python.org/3/library/ctypes.html 에 더 나와 있습니다.\n##c에서 ptyhon class까지 구현 python c extending 문법에서 python에서 class 처럼 사용가능하게 Define new types 기능(?)을 제공한다. 아래의 코드가 Define new types을 하기위한 작업입니다.\nstatic PyTypeObject NoddyType = { PyVarObject_HEAD_INIT(NULL, 0) \u0026quot;noddy.Noddy\u0026quot;, /* tp_name */ sizeof(Noddy), /* tp_basicsize */ 0, /* tp_itemsize */ (destructor)Noddy_dealloc, /* tp_dealloc */ 0, /* tp_print */ 0, /* tp_getattr */ 0, /* tp_setattr */ 0, /* tp_compare */ 0, /* tp_repr */ 0, /* tp_as_number */ 0, /* tp_as_sequence */ 0, /* tp_as_mapping */ 0, /* tp_hash */ 0, /* tp_call */ 0, /* tp_str */ 0, /* tp_getattro */ 0, /* tp_setattro */ 0, /* tp_as_buffer */ Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, /* tp_flags */ \u0026quot;Noddy objects\u0026quot;, /* tp_doc */ 0, /* tp_traverse */ 0, /* tp_clear */ 0, /* tp_richcompare */ 0, /* tp_weaklistoffset */ 0, /* tp_iter */ 0, /* tp_iternext */ Noddy_methods, /* tp_methods */ Noddy_members, /* tp_members */ 0, /* tp_getset */ 0, /* tp_base */ 0, /* tp_dict */ 0, /* tp_descr_get */ 0, /* tp_descr_set */ 0, /* tp_dictoffset */ (initproc)Noddy_init, /* tp_init */ 0, /* tp_alloc */ Noddy_new, /* tp_new */ };  멤버 함수는 위 코드의 tp_methos 부분에 PyMethodDef 구조체 배열을 인자로서 넘긴다.\nstatic PyMethodDef Noddy_methods[] = { {\u0026quot;setOption\u0026quot;, (PyCFunction)setOption, METH_VARARGS}, {\u0026quot;setFile\u0026quot;, (PyCFunction)setFile, METH_VARARGS}, {\u0026quot;setString\u0026quot;, (PyCFunction)setString, METH_VARARGS}, {\u0026quot;setOutputFile\u0026quot;, (PyCFunction)setOutputFile, METH_VARARGS}, {\u0026quot;start\u0026quot;, (PyCFunction)start, METH_VARARGS}, {NULL} /* Sentinel */ };  멤버 변수는 tp_members 부분에 구조체를 배열을 인자로서 넘긴다.\ntypedef struct { PyObject_HEAD PyObject* input; PyObject* output; PyObject* option; int type; } Noddy;  위 처럼 코드를 작성한 후 파이썬에서 일반 클래스 처럼 사용이 가능하다.\n"
},
{
	"uri": "https://kontlk.github.io/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://kontlk.github.io/contents/konltk-main/",
	"title": "konltk main",
	"tags": [],
	"description": "KoNLTK Main",
	"content": "konltk main\n"
},
{
	"uri": "https://kontlk.github.io/documents/python-2%EB%B2%84%EC%A0%84-%EB%B0%B0%ED%8F%AC%EC%8B%9C-%EC%84%9C%EB%B8%8C-%EB%AA%A8%EB%93%88-%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0/",
	"title": "python 2버전 배포시 서브 모듈 설정하기",
	"tags": ["python", "c"],
	"description": "",
	"content": " python 2버전 배포시 서브 모듈 설정하기 python 서브모듈 파이썬에서는 폴더별로 서브모듈이 나뉘어진다.\nfoo |--tmp | |--__init__.py | |--tmp.py | |--foo.py  위와 같이 파일구조로 되어있다면 실제로 파이썬에서는\nimport foo.tmp.tmp  디렉토리 구조로서 서브모듈을 접근이 가능하다.\npython extending with c 서브모듈 설정 서브모듈을 설정하기 위해서 우선 c code의 InitModule을 할 때 서브 모듈명을 명시를 해야한다. Py_InitModule(\u0026quot;foo.tmp.tmp\u0026quot;, methods, \u0026quot;\u0026quot;) 서브 모듈명은 자신이 사용하고 싶은 모듈명을 명시하면 된다.\n파이썬3버전에서는 위의 단계만하여도 실제로 사용하는데에 있어서 문제가 없다. 하지만 파이썬2버전에서 각 폴더에 __init__.py가 존재해야지 서브모듈로서 사용이 가능하다.\npython extending with c를 install을 하면 각 파이썬 파일이 python package위치에 복사가 된다. 여기서 __init__.py파일은 복사가 되지 않기 때문에 서브모듈이 적용이 안된다.\n서브 모듈을 적용 시키기 위해서 setup함수의 인자 중 packages 와 package_dir를 사용하면 __init__.py파일도 같이 복사가 된다.(아직 복사인지 생성인지 잘 모르겠다.)\n만약에 initmodule에서 명시한 서브모듈중에서 물리적으로 폴더가 존재하지 않는다면 물리적인 폴더를 생성하여서 같이 포함하면 된다.\n"
},
{
	"uri": "https://kontlk.github.io/tags/%EB%B0%B0%ED%8F%AC/",
	"title": "배포",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://kontlk.github.io/documents/%EC%98%A4%ED%94%88%EC%86%8C%EC%8A%A4%EC%97%90-contribution-%ED%95%98%EA%B8%B0/",
	"title": "오픈소스에 contribution 하기",
	"tags": ["open source", "github", "controbution"],
	"description": "",
	"content": " github에서 오픈소스 컨트리뷰션 하기 프로젝트 fork하기 우선 컨트리뷰션하고 싶은 오픈소스의 깃허브에 들어가서 fork를 해야합니다.\n여기서는 konlp로 예시를 들어보겠습니다.\nkonlp 여기에 들어가 우측 상단에 있는 fork버튼을 눌러 자신의 github 계정에 프로젝트를 복사를 한다.\n흐름 여기서는 브랜치를 따로 만들어서 하는것이라니라 master 브랜치에서 진행한 것을 예로 듭니다. 1. 내용을 수정하여서 커밋한다. 2. 자신의 GitHub 프로젝트에 Push를 한다. 3. Pull Request를 한다. 4. 프로젝트 소유자가 Requset를 Merge한다.\n흐름은 위와 같이 진행이 된다.\nPull Request 하기 자기가 원하는 프로젝트를 fork하였다면 github.com/\u0026lt;자신의 github\u0026gt;/\u0026lt;fork 한 프로젝트 명\u0026gt;에 프로젝트가 복사되었다.\n수정할 부분을 수정을 하고 request를 하고 싶다면 자신이 복사한 프로젝트의 github로 들어가서 New Pull Request버튼을 눌러 Pull Request 요청을 한다.\n다시 중간에 Create pull request 버튼을 눌러 request를 생성한다.\n앞으로 생성할 request의 제목과 설명을 적은 다음 밑의 Create pull request의 버튼을 눌러 최종 request생성을 한다.\n이제 프로젝트 소유자가 request의 내용을 확인하고 merge를 하거나 close를 한다.\n출처 출처\n"
},
{
	"uri": "https://kontlk.github.io/documents/%ED%8C%8C%EC%9D%B4%EC%8D%AC-%ED%8C%8C%EC%9D%BC-%EB%B0%B0%ED%8F%AC/",
	"title": "파이썬 배포 할 때 파일을 포함하는 방법",
	"tags": ["python", "배포"],
	"description": "",
	"content": " 파이썬 배포 할 때 파일을 포함하는 방법 자신이 짠 파이썬 코드를 배포를 하고 싶을 때는 distutiles.core모듈을 사용하여서 배포가 가능한 형태로 만들 수가 있다. disturils.code 모듈의 setup함수를 사용하여서 배포할 패키지를 구성할 수 있다. setup함수에서 여러 구성요소는 python docs 2.7에서 확인할 수 있다.\n여기서 data_files옵션을 이용하여서 파일도 포함하여 배포하는것을 볼 것이다.\nsetup.py src/ ____data/ ________data1.dat ________data2.dat ________data3.dat  위와 같이 파일 구조를 가지고 있는다면 setup함수 내에서 data_files1옵션을 아래와 같이 사용할 수 있다.\nsetup( name=\u0026quot;cho\u0026quot; ... data_files=[(\u0026quot;data\u0026quot;, [\u0026quot;src/data/data1.dat\u0026quot;, \u0026quot;src/data/data2.dat\u0026quot;, \u0026quot;src/data/data3.dat\u0026quot;])] )#end setup  python3 setup.py install 명령어를 실행 후 /usr/local/을 확인하면 data폴더가 생성되어서 파일복사가 잘 이뤄진것을 볼 수 있다.\n파일 복사의 위치는 순수 python은 sys.prefix, 확장 모듈을 포함하는 패키지의 경우는 sys.exec_prefix이다. python doc\n파일안의 모든 파일 폴더안의 모든 파일을 넘기고 싶다면 아래 코드와 같이 glob모듈을 사용하여서 파일 리스트를 사용하면 된다.\nimport glob def find_data_files(srcdir): temp = [] for f in glob.iglob(srcdir, recursive=True): temp.append(f) return temp  setup( name=\u0026quot;cho\u0026quot; ... data_files=[(\u0026quot;data\u0026quot;, find_data_files(\u0026quot;/home/cho/sample/src/data/\u0026quot;)] )#end setup  "
}]